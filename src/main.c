/* Copyright (C) 2023 Harry Clark */

/* Dynamic DLL to DOL toolkit for Riivolution */

/* THIS FILE PERTAINS TO THE MAIN FUNCTIONALITY OF THE PROGRAM */

/* NESTED INCLUDES */

#include "util.h"

#ifdef DOL_HEADER

/* DETERMINE THE ORIGIN OF THE ALLOCATED OBJECT FILE MEMORY */
/* ON THE STACK BY DETEMINING THE SIZE OF THE PHYSICAL ADDRESS */
/* THE ADDRESS OF WHICH THE ALLOCATED MEMORY IS STORED READY FOR PARSING */

static inline DOL::INC_ALLOC* INC_BSS_ALLOC(DOL* HEADER, ELF::TYPES* ELF)
{

#ifdef USE_UTIL

	if (DOL::FLAGS & DOL_HAS_BSS)
	{
		HEADER->ORG += SWAP_BIG_ENDIAN(sizeof(HEADER->ADDR));
		HEADER->ORG_SIZE += SWAP_BIG_ENDIAN(sizeof(HEADER->SIZE));
		HEADER->ADDR += SWAP_BIG_ENDIAN(sizeof(ELF->PHYSICAL_ADDR));

		/* READ FROM THE PHYSICAL ADDRESS IN A BIG ENDIAN FASHION */
		/* AS AND WHEN THE ORIGIN IS PROPORTIONAL TO A PHYSICAL ADDRESS */
		/* OTHERWISE ALLOCATE OR THE MEMORY SIZE TO MAKE ACCMMODATIONS */

		if ((HEADER->ORG) += sizeof(ELF->PHYSICAL_ADDR))
		{
			HEADER->ORG_SIZE += SWAP_BIG_ENDIAN(sizeof(HEADER->SIZE));
		}

		else
		{
			HEADER->ORG += SWAP_BIG_ENDIAN(sizeof(ELF->PHYSICAL_ADDR));
			HEADER->ORG_SIZE += SWAP_BIG_ENDIAN(sizeof(ELF->MEM_SIZE));
			ELF->MEM_FLAGS = DOL_HAS_BSS;
		}
	}

#endif 

}

/* WRITE THE CONTENTS TO THE CORRESPONDING DOL FILE */
/* USING THE PRE-REQUISTIE HEADER FILE */

/* THIS WILL BE ACHIEVED BY WRITING THE BYTEWISE CONTENTS OF THE MOD IN QUESTION */
/* FOR PROVIDED CONTEXT, LETS ASSUME THAT A DLL IS BEING CONVERTED TO DOL */
/* THE BITS OF THE FILE WILL BE WRITTEN */

#ifdef DOL_HEADER

static void WRITE_CONTENTS(DOL* DOL, FILE* FILE, const char* OPEN_FILE)
{
	FILE = fopen(OPEN_FILE, "wb");
	DOL->WRITTEN += fwrite(&DOL->HEADER, sizeof(DOL), NULL, NULL);

	WRITE_ENDIANESS((DOL), NULL);
	fclose(FILE);

}

/* WHEN WRITING THE CONTENTS OF THE FILE, IT IS IMPORTANT TO DETERMINE THE READ */
/* DIRECTION FROM WHICH THE BITS WILL BE READ FROM THE ORIGIN ALL THE WAY THROUGH THE STACK */

/* I AM USING BIG ENDIAN TO ALLOW FOR THE EASE OF USE OF BEING ABLE TO STORE THE MSB */
/* AT THE SMALLEST MEMORY ADDRESS IN ORDER TO FETCH THE MEMORY ADDRESS OF THE CONTENT MORE EFFICIENTLY */

static void WRITE_ENDIANESS(DOL* DOL, ELF::TYPES* TYPES)
{
	for (U32 i = 0; i < MAX(1, sizeof(DOL)); i++)
	{
		SWAP_BIG_ENDIAN(1, sizeof(DOL->HEADER->ADDR[i]));
		SWAP_BIG_ENDIAN(1, sizeof(TYPES->OFFSET[i]));
	}
}

#endif

#endif
