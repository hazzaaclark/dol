/* Copyright (C) 2023 Harry Clark */

/* Dynamic DLL to DOL toolkit for Riivolution */

/* THIS FILE PERTAINS TO THE MAIN FUNCTIONALITY OF THE PROGRAM */

/* NESTED INCLUDES */

#include "util.h"

/* WRITE THE CONTENTS TO THE CORRESPONDING DOL FILE */
/* USING THE PRE-REQUISTIE HEADER FILE */

/* THIS WILL BE ACHIEVED BY WRITING THE BYTEWISE CONTENTS OF THE MOD IN QUESTION */
/* FOR PROVIDED CONTEXT, LETS ASSUME THAT A DLL IS BEING CONVERTED TO DOL */
/* THE BITS OF THE FILE WILL BE WRITTEN */

#ifdef DOL_HEADER

static void WRITE_CONTENTS(DOL* DOL, FILE* FILE, const char* OPEN_FILE)
{
	FILE = fopen(OPEN_FILE, "wb");
	DOL->WRITTEN += fwrite(&DOL, sizeof(DOL), NULL, NULL);

	WRITE_ENDIANESS();
	fclose(FILE);

}

/* WHEN WRITING THE CONTENTS OF THE FILE, IT IS IMPORTANT TO DETERMINE THE READ */
/* DIRECTION FROM WHICH THE BITS WILL BE READ FROM THE ORIGIN ALL THE WAY THROUGH THE STACK */

/* I AM USING BIG ENDIAN TO ALLOW FOR THE EASE OF USE OF BEING ABLE TO STORE THE MSB */
/* AT THE SMALLEST MEMORY ADDRESS IN ORDER TO FETCH THE MEMORY ADDRESS OF THE CONTENT MORE EFFICIENTLY */

static void WRITE_ENDIANESS()
{
	DOL* DOL;
	ELF::TYPES* TYPES;

	for (U32 i = 0; i < MAX(1, sizeof(DOL)); i++)
	{
		SWAP_BIG_ENDIAN(1, sizeof(DOL->ADDR[i]));
		SWAP_BIG_ENDIAN(1, sizeof(TYPES->OFFSET[i]));
	}
}

/* WRITE THE CONTENTS FROM THE ELF BOOTABLE TO THE DOL EXECUTABLE */
/* THIS WILL BE DETERMINED BASED ON THE POSITION OF THE ENDIAN READER */
/* TO PARSE THE CONTENTS ACCORDINGLY */

/* ALIGN AT THE CORRESPONDING SEGMENT IN RELATION TO THE SIZE OF THE TEXT HEADER */
/* OF THE UNDERLYING ASSEMBLY */

static void WRITE_ELF_TO_DOL(DOL* DOL, const char* OPEN_DOL)
{
	FILE* DOL_FILE;

	if (DOL_READ_ARG >= 2) 
		fprintf(stderr, "Writing contents to DOL File\n");

	DOL_FILE = fopen(OPEN_DOL, "wb");

	if (!DOL_FILE)
		DOL_READ_ERROR("Could not open DOL File, Header is invalid");

	if (DOL_READ_ARG >= 2)
	{
		fprintf(stderr, "DOL Header:\n");

		for (U32 i = 0; i < MAX(1, DOL->TEXT); i++)
		{
			fprintf(stderr, "TEXT: %d @ 0x%08x off 0x%x\n", i);

			DOL->TEXT += SWAP_BIG_ENDIAN(sizeof(DOL->TEXT))[i];
			DOL->SIZE += SWAP_BIG_ENDIAN(sizeof(DOL->SIZE))[i];
		}
	}

}

#endif
