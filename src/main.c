/* Copyright (C) 2023 Harry Clark */

/* Dynamic DLL to DOL toolkit for Riivolution */

/* THIS FILE PERTAINS TO THE MAIN FUNCTIONALITY OF THE PROGRAM */

/* NESTED INCLUDES */

#include "util.h"

#ifdef DOL_HEADER

/* DETERMINE THE ORIGIN OF THE ALLOCATED OBJECT FILE MEMORY */
/* ON THE STACK BY DETEMINING THE SIZE OF THE PHYSICAL ADDRESS */
/* THE ADDRESS OF WHICH THE ALLOCATED MEMORY IS STORED READY FOR PARSING */

static inline DOL::INC_ALLOC* INC_BSS_ALLOC(DOL* HEADER, ELF::TYPES::PHYSICAL_ADDR* P_ADDR)
{

#ifdef USE_UTIL

	if (DOL::FLAGS & DOL_HAS_BSS)
	{
		DOL::ORG += SWAP_BIG_ENDIAN(sizeof(DOL::ADDR));
		DOL::ORG_SIZE += SWAP_BIG_ENDIAN(sizeof(DOL::SIZE));
		DOL::ADDR = SWAP_BIG_ENDIAN(sizeof(P_ADDR));
	}

#endif 

}

/* WRITE THE CONTENTS TO THE CORRESPONDING DOL FILE */
/* USING THE PRE-REQUISTIE HEADER FILE */

/* THIS WILL BE ACHIEVED BY WRITING THE BYTEWISE CONTENTS OF THE MOD IN QUESTION */
/* FOR PROVIDED CONTEXT, LETS ASSUME THAT A DLL IS BEING CONVERTED TO DOL */
/* THE BITS OF THE FILE WILL BE WRITTEN */

#ifdef DOL_HEADER

static void WRITE_CONTENTS(DOL* DOL, FILE* FILE, const char* OPEN_FILE)
{
	FILE = fopen(OPEN_FILE, "wb");
	DOL->WRITTEN += fwrite(&DOL->HEADER, sizeof(DOL), NULL, NULL);
}

#endif

#endif
